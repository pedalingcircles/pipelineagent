# Ideally we would use GitHub Actions for this, but since we use self-hosted machines to run image builds
# we need the following features to use GitHub Actions for Images CI:
# - https://github.community/t5/GitHub-Actions/Make-secrets-available-to-builds-of-forks/m-p/30678#M508
# - https://github.community/t5/GitHub-Actions/GitHub-Actions-Manual-Trigger-Approvals/td-p/31504
# - https://github.community/t5/GitHub-Actions/Protecting-github-workflows/td-p/30290

parameters:
- name: image_type
  type: string
- name: image_readme_name
  type: string
- name: imageDefinitionName
  type: string
- name: versionMajor
  type: number
- name: versionMinor
  type: number

jobs:
- job:
  displayName: VM Image Generation (${{ parameters.image_type }})
  timeoutInMinutes: 600
  cancelTimeoutInMinutes: 30
  variables:
  - group: Image Generation Variables
  - template: variables-vmimage-generation.yml
  - template: variables-version-semantic.yml
    parameters:
      versionMajor: ${{ parameters.versionMajor }}
      versionMinor: ${{ parameters.versionMinor }}
  - name: dateVersion
    value: $[format('{0:yyyyMMdd}', pipeline.startTime)]
  - name: dateVersionCounter
    value: $[counter(format('{0:yyyyMMdd}', pipeline.startTime), 0)]

  steps:
  - task: PowerShell@2
    displayName: 'Set image template variables'
    inputs:
      targetType: 'inline'
      script: |
        $ImageType = "${{ parameters.image_type }}"
        Write-Host "ImageType=$ImageType"
        $TemplateDirectoryName = if ($ImageType.StartsWith("ubuntu")) { "linux" } else { "win" }
        Write-Host "TemplateDirectoryName=$TemplateDirectoryName"
        $TemplateDirectoryPath = Join-Path ".virtual-environments/images" $TemplateDirectoryName | Resolve-Path
        Write-Host "TemplateDirectoryPath=$TemplateDirectoryPath"
        $TemplatePath = Join-Path $TemplateDirectoryPath "$ImageType.json"
        Write-Host "##vso[task.setvariable variable=TemplateDirectoryPath;]$TemplateDirectoryPath"
        Write-Host "##vso[task.setvariable variable=TemplatePath;]$TemplatePath"
        Write-Host "TemplatePath=$TemplatePath"

  - task: PowerShell@2
    displayName: 'Get Agent IP'
    inputs:
      targetType: 'inline'
      script: |
        $AgentIp = (Invoke-RestMethod http://ipinfo.io/json).ip
        Write-Host "Restricting access to packer generated VM to agent IP Address: $AgentIp"
        Write-Host "##vso[task.setvariable variable=AgentIp;]$AgentIp"

  - task: PowerShell@2
    displayName: 'Build VM'
    inputs:
      targetType: filePath
      filePath: ./.azure/pipelines/scripts/build-image.ps1
      arguments: >
        -ResourcesNamePrefix $(Build.BuildId)
        -ClientId $(CLIENT_ID)
        -ClientSecret $(CLIENT_SECRET)
        -TemplatePath $(TemplatePath)
        -ResourceGroup $(AZURE_RESOURCE_GROUP)
        -StorageAccount $(AZURE_STORAGE_ACCOUNT)
        -SubscriptionId $(AZURE_SUBSCRIPTION)
        -TenantId $(AZURE_TENANT)
        -Location $(AZURE_LOCATION)
        -VirtualNetworkName $(BUILD_AGENT_VNET_NAME)
        -VirtualNetworkRG $(BUILD_AGENT_VNET_RESOURCE_GROUP)
        -VirtualNetworkSubnet $(BUILD_AGENT_SUBNET_NAME)
        -AgentIp $(AgentIp)
    env:
      PACKER_LOG: 1
      PACKER_LOG_PATH: $(Build.ArtifactStagingDirectory)/packer-log.txt

  - task: PowerShell@2
    displayName: 'Output Readme file content'
    inputs:
      targetType: 'inline'
      script: |
        Get-Content -Path (Join-Path "$(TemplateDirectoryPath)" "${{ parameters.image_readme_name }}")

  - task: PowerShell@2
    displayName: 'Print provisioners duration'
    inputs:
      targetType: 'filePath'
      filePath: ./.azure/pipelines/scripts/measure-provisioners-duration.ps1
      arguments: >
        -PackerLogPath "$(Build.ArtifactStagingDirectory)/packer-log.txt"
        -PrefixToPathTrim "$(TemplateDirectoryPath)"
        -PrintTopNLongest 25
        
  - task: AzureCLI@2
    displayName: 'Convert to Managed Image'
    inputs:
      azureSubscription: AgentManagement
      scriptType: pscore
      scriptLocation: scriptPath
      scriptPath: $(System.DefaultWorkingDirectory)/.azure/pipelines/scripts/ConvertTo-ManagedImage.ps1
      arguments: >
        -ContainerName $(PackerFinishedImageContainerName)
        -DateVersion $(dateVersion)
        -DateVersionCounter $(dateVersionCounter)
        -Location $(AZURE_LOCATION)
        -Prefix Microsoft.Compute/Images/images/24033
        -ResourceGroupName $(AZURE_RESOURCE_GROUP)
        -StorageAccountName $(AZURE_STORAGE_ACCOUNT)
        -ImageType ${{ parameters.image_type }}
        -Tags project=$(System.TeamProject),builddefinitionid=$(System.DefinitionId),commit=$(Build.SourceVersion),branch=$(Build.SourceBranch),repo=$(Build.Repository.Name),repourl=$(Build.Repository.Uri),buildid=$(Build.BuildId)
        -Clean

  - task: AzureCLI@2
    displayName: 'Publish to Shared Image Gallery'
    inputs:
      azureSubscription: AgentManagement
      scriptType: pscore
      scriptLocation: scriptPath
      scriptPath: $(System.DefaultWorkingDirectory)/.azure/pipelines/scripts/Publish-ImageToSharedGallery.ps1
      arguments: >
        -ResourceGroupName $(AZURE_RESOURCE_GROUP)
        -SharedImageGalleryName $(SharedImageGalleryName)
        -ImageDefinitionName ${{ parameters.imageDefinitionName }}
        -ImageDefinitionDescription 'foobar description'
        -Location $(AZURE_LOCATION)
        -ImagePublisher $(ImagePublisher)
        -ImageOffer 'foo'
        -ImageSku 'bar'
        -OsType 'Linux'
        -ImageVersion $(versionSemantic)
        -ImageName $(imageName)
        -EndOfLifeDate $(EndOfLife)
        -ImageVersionTags $(System.TeamProject),builddefinitionid=$(System.DefinitionId),commit=$(Build.SourceVersion),branch=$(Build.SourceBranch),repo=$(Build.Repository.Name),repourl=$(Build.Repository.Uri),buildid=$(Build.BuildId)
        -ImageDefinitionTags project=$(System.TeamProject),builddefinitionid=$(System.DefinitionId),commit=$(Build.SourceVersion),branch=$(Build.SourceBranch),repo=$(Build.Repository.Name),repourl=$(Build.Repository.Uri),buildid=$(Build.BuildId)
        -Clean

  - task: PublishBuildArtifacts@1
    displayName: 'Publish ServicesBuild'
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)'
      ArtifactName: drop

  - task: PowerShell@2
    displayName: 'Clean up resources'
    condition: always()
    inputs:
      targetType: filePath
      filePath: ./.azure/pipelines/scripts/cleanup.ps1
      arguments: -ResourcesNamePrefix $(Build.BuildId) `
                     -Image ${{ parameters.image_type }} `
                     -StorageAccount $(AZURE_STORAGE_ACCOUNT) `
                     -SubscriptionId $(AZURE_SUBSCRIPTION) `
                     -ClientId $(CLIENT_ID) `
                     -ClientSecret $(CLIENT_SECRET) `
                     -TenantId $(AZURE_TENANT)
